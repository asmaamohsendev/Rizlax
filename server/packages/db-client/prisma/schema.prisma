generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  String      @id @default(uuid())
  email               String      @unique
  password            String?
  name                String
  phoneNumber         String?     @unique
  country             CountryCode @default(EG)
  role                Role
  status              UserStatus  @default(ACTIVE)
  isVerified          Boolean     @default(false)
  onBoardingCompleted Boolean     @default(false)
  onBoardingStep      Int         @default(1)

  createdAt                        DateTime                  @default(now())
  updatedAt                        DateTime                  @updatedAt
  suspendedUntil                   DateTime?
  // OAuth fields
  googleId                         String?                   @unique
  profilePicture                   String?
  violations                       UserViolation[]
  authProvider                     AuthProvider              @default(EMAIL)
  Client                           Client?
  Freelancer                       Freelancer?
  refreshTokens                    RefreshToken[]
  Message_Message_receiverIdToUser Message[]                 @relation("Message_receiverIdToUser")
  Message_Message_senderIdToUser   Message[]                 @relation("Message_senderIdToUser")
  conversationsAsParticipant       ConversationParticipant[]

  wallet Wallet?

  // Media service relations
  verificationDocuments VerificationDocument[]
  jobAssets             JobAsset[]
  chatAttachments       ChatAttachment[]
  mediaFiles            MediaFile[]
  articles              Article[]
  notifications         Notification[]
  disputesRaised        Dispute[]              @relation("Dispute_RaisedBy")
  disputeMessages       DisputeMessage[]
}

enum CountryCode {
  EG // Egypt
  SA // Saudi Arabia
  AE // United Arab Emirates
  KW // Kuwait
  QA // Qatar
  BH // Bahrain
  OM // Oman
  JO // Jordan
  LB // Lebanon
  IQ // Iraq
  SY // Syria
  PS // Palestine
  YE // Yemen
  MA // Morocco
  DZ // Algeria
  TN // Tunisia
  LY // Libya
  SD // Sudan
  MR // Mauritania
  SO // Somalia
  DJ // Djibouti
  PK // Pakistan
  ID // Indonesia
  TR // Turkey
  IR // Iran
}

model RefreshToken {
  id String @id @default(uuid())

  token String @unique

  expiresAt DateTime

  createdAt DateTime @default(now())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model Conversation {
  id            String   @id @default(uuid())
  title         String?
  lastMessageId String?  @unique
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  lastActivity  DateTime @default(now())

  // Relations
  participants ConversationParticipant[]
  messages     Message[]
  lastMessage  Message?                  @relation("ConversationLastMessage", fields: [lastMessageId], references: [id])
  attachments  ChatAttachment[]
}

model ConversationParticipant {
  conversationId String
  userId         String

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([conversationId, userId])
  @@index([userId])
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  FILE
}

enum MessageStatus {
  SENT
  DELIVERED
  READ
  FAILED
}

model Message {
  id             String        @id @default(uuid())
  conversationId String
  senderId       String
  receiverId     String
  content        String
  timestamp      DateTime      @default(now())
  readAt         DateTime?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  type           MessageType   @default(TEXT)
  status         MessageStatus @default(SENT)

  // Relations
  conversation       Conversation     @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender             User             @relation("Message_senderIdToUser", fields: [senderId], references: [id])
  receiver           User             @relation("Message_receiverIdToUser", fields: [receiverId], references: [id])
  ConversationAsLast Conversation?    @relation("ConversationLastMessage")
  attachments        ChatAttachment[]

  // Indexes for efficient queries
  @@index([conversationId, timestamp])
  @@index([receiverId, readAt])
  @@index([senderId, timestamp])
  @@index([conversationId, receiverId, readAt])
}

model UserViolation {
  id            String    @id @default(cuid())
  userId        String    @map("user_id")
  violationType String    @map("violation_type")
  severity      String
  content       String    @db.Text
  expiresAt     DateTime? @map("expires_at")
  createdAt     DateTime  @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_violations")
}

model Otp {
  id          String    @id @default(cuid())
  email       String
  otp         String
  type        OtpType
  status      OtpStatus @default(PENDING)
  userId      String?
  attempts    Int       @default(0)
  metadata    Json?
  expiresAt   DateTime
  createdAt   DateTime  @default(now())
  verifiedAt  DateTime?
  lastAttempt DateTime?

  @@index([email, type, status])
  @@index([expiresAt])
}

model Client {
  id              String     @id @default(uuid())
  userId          String     @unique
  professionTitle String?
  companyName     String?
  bio             String?
  website         String?
  location        String?
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt
  user            User       @relation(fields: [userId], references: [id])
  contracts       Contract[]
  jobs            Job[]
}

model Job {
  id          String     @id @default(uuid())
  clientId    String
  title       String
  description String
  budget      Float
  category    String
  status      JobStatus  @default(OPEN)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  contract    Contract?
  client      Client     @relation(fields: [clientId], references: [id])
  proposals   Proposal[]
  assets      JobAsset[]

  // Indexes for browse jobs performance
  @@index([status, createdAt(sort: Desc)])
  @@index([category, status])
  @@index([budget, status])
  @@index([status, budget, createdAt(sort: Desc)])
  @@index([category, budget, status])
}

model Contract {
  id           String         @id @default(uuid())
  clientId     String
  freelancerId String
  jobId        String         @unique
  proposalId   String?        @unique
  amount       Float
  currency     String         @default("USD")
  totalPaid    Float          @default(0)
  status       ContractStatus @default(PENDING)
  startDate    DateTime
  endDate      DateTime?
  submittedAt  DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  client     Client         @relation(fields: [clientId], references: [id])
  freelancer Freelancer     @relation(fields: [freelancerId], references: [id])
  job        Job            @relation(fields: [jobId], references: [id])
  proposal   Proposal?      @relation(fields: [proposalId], references: [id])
  milestones Milestone[]
  payments   Payment[]
  reviewId   String?
  review     Review?
  escrow     EscrowAccount?

  @@index([freelancerId, status])
  @@index([clientId, status])
}

model Milestone {
  id                  String          @id @default(uuid())
  contractId          String
  title               String
  description         String?
  amount              Float
  currency            String          @default("USD")
  dueDate             DateTime?
  status              MilestoneStatus @default(PENDING)
  submittedAt         DateTime?
  approvedAt          DateTime?
  paidAt              DateTime?
  disputedAt          DateTime?
  deletionRequestedAt DateTime?
  sequence            Int
  submissionUrl       String?
  escrowTransactionId String?
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt
  contract            Contract        @relation(fields: [contractId], references: [id])
}

enum MilestoneStatus {
  PENDING
  IN_PROGRESS
  SUBMITTED
  APPROVED
  PAID
  DISPUTED
  CANCELED
  COMPLETED
  REJECTED
}

model Freelancer {
  id              String                @id @default(uuid())
  userId          String                @unique
  professionTitle String?
  hourlyRate      Float?
  experienceLevel ExperienceLevel
  bio             String?
  languages       FreelancerLanguages[]
  location        String?
  isAvailable     Boolean               @default(true)
  availability    Availability?
  createdAt       DateTime              @default(now())
  updatedAt       DateTime              @updatedAt
  contracts       Contract[]
  user            User                  @relation(fields: [userId], references: [id])
  portfolioLinks  PortfolioLink[]
  proposals       Proposal[]
  reviews         Review[]
  withdrawals     Withdrawal[]
  mainCategories  MainCategory[]        @relation("FreelancerSkills")
  subCategories   SubCategory[]         @relation("FreelancerSubSkills")
}

enum Availability {
  FULL_TIME
  PART_TIME
  AS_NEEDED
}

model FreelancerLanguages {
  freelancerId        String
  languageId          String
  languageProficiency LanguageProficiency

  freelancer Freelancer @relation(fields: [freelancerId], references: [id], onDelete: Cascade)
  language   Language   @relation(fields: [languageId], references: [id], onDelete: Cascade)

  @@id([freelancerId, languageId])
  @@map("freelancer_languages")
}

model Language {
  id                  String                @id @default(uuid())
  name                String
  freelancerLanguages FreelancerLanguages[]
}

enum LanguageProficiency {
  BASIC
  CONVERSATIONAL
  FLUENT
  NATIVE
}

model MainCategory {
  id          String       @id @default(uuid())
  name        String
  freelancers Freelancer[] @relation("FreelancerSkills")
}

model SubCategory {
  id          String       @id @default(uuid())
  name        String
  freelancers Freelancer[] @relation("FreelancerSubSkills")
}

model PortfolioLink {
  id           String     @id @default(uuid())
  title        String
  description  String?
  imageUrls    String[]
  githubUrl    String?
  liveUrl      String?
  freelancerId String
  freelancer   Freelancer @relation(fields: [freelancerId], references: [id])
}

model Proposal {
  id           String         @id @default(uuid())
  freelancerId String
  jobId        String
  coverLetter  String
  proposedRate Float
  createdAt    DateTime       @default(now())
  freelancer   Freelancer     @relation(fields: [freelancerId], references: [id])
  job          Job            @relation(fields: [jobId], references: [id])
  status       ProposalStatus @default(PENDING)
  contract     Contract?
}

enum ProposalStatus {
  PENDING
  INTERVIEWING
  ACCEPTED
  DECLINED
}

model Payment {
  id         String        @id @default(uuid())
  contractId String        @unique
  amount     Int           @default(0)
  status     PaymentStatus @default(PENDING)
  method     String? // لاحقًا ممكن تكون STRIPE, PAYPAL, etc
  paidAt     DateTime?
  providerId String? // معرف الدفع من مزود الخدمة
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt

  contract Contract @relation(fields: [contractId], references: [id])
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
}

model EscrowAccount {
  id            String       @id @default(uuid())
  contractId    String       @unique @map("contract_id") // مرتبط بالعقد
  clientId      String       @map("client_id")
  freelancerId  String       @map("freelancer_id")
  heldAmount    Int          @default(0) @map("held_amount")
  initialAmount Int          @default(0) @map("initial_amount") // المبلغ الإجمالي بالقرش
  status        EscrowStatus @default(ACTIVE)
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  contract     Contract            @relation(fields: [contractId], references: [id])
  transactions EscrowTransaction[]

  @@index([contractId])
  @@index([freelancerId, status])
  @@index([clientId, status])
  @@map("escrow_accounts")
}

enum EscrowStatus {
  ACTIVE // الأموال مجمدة
  COMPLETED // تم صرف كل الأموال للمستقل
  CANCELED // تم إلغاء العقد (قد تتطلب رد أموال)
}

model EscrowTransaction {
  id                  String                @id @default(uuid())
  escrowAccountId     String
  amount              Int // بالقرش
  type                EscrowTransactionType
  description         String?
  sourceWalletId      String? // معرف محفظة العميل الذي أودع (لـ DEPOSIT)
  destinationWalletId String? // معرف محفظة المستقل الذي استلم (لـ RELEASE/REFUND)
  createdAt           DateTime              @default(now())

  escrowAccount EscrowAccount @relation(fields: [escrowAccountId], references: [id])

  @@index([escrowAccountId])
}

enum EscrowTransactionType {
  DEPOSIT
  RELEASE
  REFUND
}

model Wallet {
  id               String   @id @default(uuid())
  userId           String   @unique
  availableBalance Int      @default(0) @map("available_balance")
  pendingBalance   Int      @default(0) @map("pending_balance")
  updatedAt        DateTime @updatedAt
  createdAt        DateTime @default(now())

  user         User                @relation(fields: [userId], references: [id])
  transactions WalletTransaction[]
}

model Withdrawal {
  id           String           @id @default(uuid())
  freelancerId String
  amount       Float
  status       WithdrawalStatus @default(PENDING)
  requestedAt  DateTime         @default(now())
  processedAt  DateTime?
  method       String? // PAYPAL, BANK, etc
  notes        String? // للمراجعة أو سبب الرفض

  freelancer Freelancer @relation(fields: [freelancerId], references: [id])

  @@index([status, requestedAt])
}

enum WithdrawalStatus {
  PENDING
  APPROVED
  REJECTED
  COMPLETED
}

model WalletTransaction {
  id          String          @id @default(uuid())
  walletId    String
  amount      Int // بالقرش
  type        TransactionType
  relatedId   String? // ممكن تكون Payment ID، Withdrawal ID، إلخ
  relatedType String? // "ESCROW_RELEASE" | "WITHDRAWAL" | "REFUND"
  metadata    Json? // لو حبيت تخزن حاجة إضافية
  createdAt   DateTime        @default(now())

  wallet Wallet @relation(fields: [walletId], references: [id])

  @@index([walletId, createdAt])
}

enum TransactionType {
  DEPOSIT
  WITHDRAWAL
  HOLD
  RELEASE
  ADJUSTMENT
}

model Review {
  id           String     @id @default(uuid())
  contractId   String     @unique
  rating       Int
  feedback     String?
  createdAt    DateTime   @default(now())
  freelancerId String
  contract     Contract   @relation(fields: [contractId], references: [id])
  freelancer   Freelancer @relation(fields: [freelancerId], references: [id])

  @@index([freelancerId])
}

enum Role {
  CLIENT
  FREELANCER
  ADMIN
}

enum UserStatus {
  ACTIVE
  SUSPENDED
  BANNED
}

enum OtpType {
  PASSWORD_RESET
  EMAIL_VERIFICATION
  TWO_FACTOR_AUTH
  ACCOUNT_VERIFICATION
}

enum OtpStatus {
  PENDING
  VERIFIED
  EXPIRED
  USED
}

enum JobStatus {
  OPEN
  IN_PROGRESS
  COMPLETED
  CANCELED
  SUSPENDED
}

enum ContractStatus {
  PENDING
  ACTIVE
  COMPLETED
  DISPUTED
  TERMINATED
  REVIEW_PENDING
}

enum ExperienceLevel {
  BEGINNER
  INTERMEDIATE
  EXPERT
}

enum AuthProvider {
  EMAIL
  GOOGLE
}

model VerificationDocument {
  id              String              @id @default(uuid())
  userId          String
  docType         VerificationDocType
  fileName        String // R2 object key
  originalName    String
  fileType        String
  fileSize        Int
  status          VerificationStatus  @default(PENDING)
  uploadedAt      DateTime            @default(now())
  reviewedAt      DateTime?
  reviewedBy      String? // Admin user ID
  rejectionReason String? // Reason for rejection
  adminNotes      String? // Additional notes from admin
  metadata        Json? // Additional metadata
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, docType]) // Each user can have only one doc per type
  @@index([userId, status])
  @@index([status, uploadedAt])
  @@index([status, reviewedAt])
}

model JobAsset {
  id           String   @id @default(uuid())
  userId       String // Owner of the file
  jobId        String? // Can be null for draft jobs
  fileName     String // R2 object key
  originalName String
  fileType     String
  fileSize     Int
  category     String? // e.g., 'requirements', 'reference', 'mockup'
  isPublic     Boolean  @default(false)
  url          String? // Public URL if isPublic is true
  uploadedAt   DateTime @default(now())
  metadata     Json? // Additional metadata
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  job  Job? @relation(fields: [jobId], references: [id], onDelete: SetNull)

  @@index([userId, jobId])
  @@index([jobId, isPublic])
  @@index([uploadedAt])
}

model ChatAttachment {
  id             String   @id @default(uuid())
  userId         String // Uploader
  conversationId String
  messageId      String?
  originalName   String
  key            String   @unique
  fileType       String
  fileSize       Int
  url            String
  uploadedAt     DateTime @default(now())
  metadata       Json?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  message      Message?     @relation(fields: [messageId], references: [id], onDelete: SetNull)

  @@index([conversationId, uploadedAt])
  @@index([userId, uploadedAt])
  @@index([messageId])
}

model MediaFile {
  id           String          @id @default(uuid())
  userId       String // Owner of the file
  fileName     String // R2 object key
  originalName String
  fileType     String
  fileSize     Int
  uploadType   MediaUploadType
  category     String?
  isPublic     Boolean         @default(false)
  url          String? // Public URL if isPublic is true
  uploadedAt   DateTime        @default(now())
  metadata     Json? // Additional metadata
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, uploadType])
  @@index([uploadType, isPublic])
  @@index([uploadedAt])
}

enum VerificationDocType {
  FRONT // Front of ID
  BACK // Back of ID
  SELFIE // Selfie with ID
}

enum VerificationStatus {
  PENDING
  APPROVED
  REJECTED
  EXPIRED
}

enum MediaUploadType {
  VERIFICATION
  JOB
  CHAT
  PROFILE
  OTHER
}

model Article {
  id          String  @id @default(cuid())
  title       String
  content     String  @db.Text
  slug        String  @unique
  excerpt     String? @db.Text
  coverImage  String?
  readingTime Int?
  isFeatured  Boolean @default(false)

  published Boolean       @default(false)
  status    ArticleStatus @default(DRAFT)

  authorId String
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)

  tags ArticleTag[]

  views Int @default(0)
  likes Int @default(0)

  metaTitle       String?
  metaDescription String?
  metaKeywords    String[]

  publishedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([authorId])
  @@index([status])
  @@index([publishedAt])
  @@map("articles")
}

model Tag {
  id       String       @id @default(cuid())
  name     String       @unique
  articles ArticleTag[]
}

model ArticleTag {
  articleId String
  tagId     String

  article Article @relation(fields: [articleId], references: [id], onDelete: Cascade)
  tag     Tag     @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([articleId, tagId])
  @@map("article_tags")
}

model Notification {
  id          String             @id @default(cuid())
  type        NotificationType
  entity      NotificationEntity
  entityId    String // ID of the related entity (e.g., Article ID, Message ID)
  recipient   User?              @relation(fields: [recipientId], references: [id], onDelete: Cascade)
  recipientId String?
  title       String
  message     String
  isRead      Boolean            @default(false)
  metadata    Json?
  createdAt   DateTime           @default(now())

  emailLogs NotificationEmailLog[]

  @@index([recipientId, isRead])
  @@index([createdAt])
}

model NotificationEmailLog {
  id             String      @id @default(cuid())
  notificationId String
  email          String
  sentAt         DateTime    @default(now())
  status         EmailStatus @default(SENT)
  errorMessage   String?

  notification Notification @relation(fields: [notificationId], references: [id], onDelete: Cascade)

  @@index([notificationId])
  @@index([email])
}

model Dispute {
  id             String        @id @default(cuid())
  conversationId String
  raisedById     String
  title          String
  reason         String
  details        String        @db.Text
  status         DisputeStatus @default(OPEN)
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  resolvedAt      DateTime?
  resolvedById    String?
  resolutionNotes String?   @db.Text
  updatedById     String?

  raiser          User             @relation("Dispute_RaisedBy", fields: [raisedById], references: [id], onDelete: Cascade)
  disputeMessages DisputeMessage[]

  @@index([conversationId])
  @@index([status, createdAt])
  @@map("disputes")
}

model DisputeMessage {
  id        String   @id @default(cuid())
  disputeId String
  senderId  String
  content   String   @db.Text
  isSystem  Boolean  @default(false)
  createdAt DateTime @default(now())

  dispute            Dispute             @relation(fields: [disputeId], references: [id], onDelete: Cascade)
  sender             User                @relation(fields: [senderId], references: [id], onDelete: Cascade)
  disputeAttachments DisputeAttachment[]

  @@index([disputeId, createdAt])
  @@map("dispute_messages")
}

model DisputeAttachment {
  id               String   @id @default(cuid())
  disputeMessageId String
  fileName         String // R2 object key
  originalName     String
  fileType         String
  fileSize         Int
  url              String
  uploadedAt       DateTime @default(now())

  disputeMessage DisputeMessage @relation(fields: [disputeMessageId], references: [id], onDelete: Cascade)

  @@index([disputeMessageId])
  @@map("dispute_attachments")
}

enum DisputeStatus {
  OPEN
  UNDER_REVIEW
  RESOLVED
  CLOSED
}

enum EmailStatus {
  SENT
  FAILED
  QUEUED
}

enum NotificationType {
  ADMIN
  FREELANCER
  CLIENT
}

enum NotificationEntity {
  ARTICLE
  MESSAGE
  JOB
  PROPOSAL
  CONTRACT
  DISPUTE
  PAYMENT
  WITHDRAWAL
  ESCROW
  SYSTEM
  OTHER
}

enum ArticleStatus {
  DRAFT
  PUBLISHED
  CANCELLED
}
